# xss

## 定义:

cross site scripting, 简写应该是 css，因为跟 层叠样式表 冲突，所以改成 XSS (X 是因为 cross 表示交叉的意思，所以用 X 来表示)。 xss 是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息，如 cookie，sessionID等，进而危害数据安全。

xss的本质是：恶意代码未经过滤，与网站的正常代码混合在一起，浏览器无法识别脚本是否可信，导致恶意脚本也会被执行。

而由于直接在用户的浏览器执行，恶意代码能够直接获取用户的信息(cookie sessionId)，或者利用这些信息冒充用户向网站发起攻击者定义的请求

## 分类：

xss 攻击可以分为三种：

+ 反射型
+ 存储型
+ DOM型

### 反射型

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
1. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
1. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
1. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 的恶意代码存在 URL 里。漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

### 存储型

#### 攻击步骤

1. 攻击者将恶意代码提交到目标网站的数据库中
1. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
1. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
1. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

### DOM 型 XSS

#### 攻击步骤

1. 攻击者构造特殊的 URL，其中包含恶意代码。
1. 用户打开带有恶意代码的 URL。
1. 用户浏览器接收到响应后解析执行，前端 javascript 取出 URL 中的恶意代码并执行。
1. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别： DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 Javascript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

## XSS 攻击的预防

XSS 攻击有两大要素：

1. 攻击者提交恶意代码
1. 浏览器执行恶意代码

针对第一个要素，是否是否能够在用户输入的过程，过滤掉用户输入的恶意代码？

### 输入过滤

在用户提交时，由前端过滤输入，然后提交到后端，这样做是否可行？

答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。

换一个过滤时机：后端再写入数据库前，对输入进入过滤，然后把 '安全的' 内容返回给前端，这样是否可行？

这个能解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法，举个例子说明：

比如用户正常输入 5 < 7, 在存入数据库前进行转化，变成 5 &lt; 7。这个内容输出到不同地方会有不同的情况出现：

1. 如果是作为 HTML 内容拼接输出到页面上，那会正常显示，没有问题
1. 如果是输出到其他客户端，比如 app 这种非浏览器环境，就会原内容显示，显示就会有问题
1. 如果是通过 ajax 返回，然后赋值给 javascript 的变量时，前端得到的是转义后的字符串，不能直接用于内容长度计算。不能用于标题、alert 等

既然输入过滤并非完全可靠，就要通过 '防止浏览器执行恶意代码' 来防范 XSS。这个又分为两类：

+ 防止 HTML 中出现注入
+ 防止 Javascript 执行时，执行恶意代码

### 预防 存储型 和 反射型 XSS 攻击

存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的 '数据' 被内嵌到 '代码' 中，被浏览器所执行。

预防这两种漏洞，有两种常见的做法：

+ 改成纯前端渲染，把代码和数据分隔开
+ 对 HTML 做充分转义

#### 纯前端渲染

也就是目前最常见的前端开发方式，html 不包含业务数据，通过加载执行 JavaScript, 再通过 Ajax 加载业务数据，调用 DOM Api 更新页面

这种方式，会明确告诉浏览器要设置的内容是文本 (.innerText), 还是属性 (.setAttribute), 还是样式 (.style) 等等。所以浏览器不会被轻易欺骗，执行预期外的代码。

但纯前端渲染还需注意避免 DOM 型 XSS 攻击。

#### 转义 HTML

如果拼接 HTML 是必要的，比如需要设置 .innerHTML 属性，就需要采用合适的转义库，

对于 HTML 转义通常只有一个规则，就是把 & < > " ' / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善。

### 预防 DOM 型 XSS 攻击

DOM 型 XSS 攻击，实际上就算前端网站 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 .innerHTML、.outHTML、 document.write() 时要特别小心，不要把不可信的数据作为 HTML 插入到页面上，而应尽量使用 .textContent、 .setAttribute 等。

如果是使用 React 要用 dangerouslySetInnerHTML， Vue 要用 v-html；

DOM 中的 __内联__ 事件监听器，如 onload, onclick 等，还有 location、 `<a>` 标签的 href 属性， JavaScript 的 eval()， setTimeout() 等能把字符串作为代码运行，像这些都是可以把不可信的数据拼接到字符串导致代码执行，因此要尽量避免。

### 其他 XSS 防范措施

虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的，还可以结合以下一些方案来防范

+ Content Security Policy
+ 输入内容长度限制（ 对于不信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但是可以增加 XSS 攻击的难度。）
+ HTTP-only Cookie: 禁止 JavaScript 读取某些敏感的 Cookies，攻击者完成 XSS 注入后也无法窃取 Cookies。

## 总结

整体的 XSS 防范非常复杂和繁琐，不仅要在全部需要转义的位置，对数据进行对应的转义；而且要防止多余和错误的转义，避免正常的用户输入出现乱码。

虽然很难通过技术手段完全避免 XSS，但遵循以下原则可以帮忙减少漏洞的产生:

+ 利用模板引擎：开启模板引擎自带的 HTML 转义功能。这个一般是在服务端生成 HTML 内容处理。
+ 避免内联事件：尽量不使用 onLoad="onload('{{data}}')"、onClick="go('{{action}}')" 这种拼接内联事件的写法。在 JavaScript 中通过 addEventListener 注册事件更安全。
+ 避免拼接 HTML: 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现，或者采用成熟的渲染框架，如 react、vue
+ 时刻保持警惕：在插入位置是 DOM 属性，链接等位置时，要特别注意
+ 增加攻击难度、降低攻击后果：通过 csp、输入长度控制 等方法
+ 主动检测和发现：可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。