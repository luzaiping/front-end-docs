前端工程师的自检清单 - 编译原理篇
=========================
内容参考自[掘金-一个前端工程的自检清单](https://juejin.im/post/5cc1da82f265da036023b628)。该文章列出了清单内容，这边会对清单项进行解答。

1. 理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序
> 了解即可，可以参考[这篇文章](https://www.zhihu.com/question/29227521)

2. 正则表达式的匹配原理和性能优化
> 匹配原理：完全不会，有空了再来看。参考[这篇文章](https://www.jianshu.com/p/fb3afbf8da10)
> 性能优化：完全不会，有空了再来看。参考[这篇文章](https://www.jianshu.com/p/bbf3c382fd30)

3. 如何将JavaScript代码解析成抽象语法树(AST)
> 这个必须得会。参考[这篇文章](https://segmentfault.com/a/1190000016231512)

4. base64编码原理
> 首先定义一个 BASE64 的索引表，字符选用了 `A-Z, a-z, 0-9, +, /` 总共64个字符
> 转换步骤：
>> 1. 将待转换的字符串每3个字节分为一组，每个字节占8bit，那么就有24个二进制位
>> 2. 将上面的24个二进制位每6个分为一组，总共分为4组
>> 3. 在每组前面添加2个0，每组有6个变为8个二进制位，总共32个二进制位，即4个字节
>> 4. 根据 base64 编码索引表，获得对应的值

从上面的步骤可以发现：

+ Base64 字符表中的字符原本用6个bit就可以表示，现在前面添加2个0，变为8个bit，会造成一定的浪费。因此，Base64编码之后的文本，要比原文大约三分之一。
+ 为什么使用3个字节一组呢？因为6和8的最小公约数是24，3个字节正好24个二进制位，每6个bit一组，恰好能够分为4组。

> https://blog.csdn.net/wo541075754/article/details/81734770