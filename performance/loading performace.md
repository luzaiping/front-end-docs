# 加载性能

页面绝大多数的时间是花在下载资源上面，而不是渲染显示。提升资源下载速度可以从以下方面入手：

1. 减少资源大小，资源越小下载速度就会越快，这个主要针对 text content
1. 减少请求数(相比http/1而已)，一个站点的并发请求数是有限，如果有太多请求，就会有一部分资源需要排队等其他请求结束后才能执行.
1. 优化资源加载顺序，必须要加载的资源，要考虑加载顺序，减少页面的阻塞和等待

## 减小资源大小

### minify

  像 html/js/css 这类文本型的资源，部署到生产环境前，要借助各种 minify 工具包进行处理，minify 主要是去掉 空格、空白行、注释；通过 minify 后，能有效减少资源大小，同时不影响任何功能。

  对于js，还可以通过 uglify 处理，缩短变量名和方法名

  SVG 本质是文本型的图片格式，可以通过 svgo 进行优化

### gzip

  minify 后的html/js/css，可以通过 GZIP 进一步减少资源大小；GZIP 比起minify 能更显著减少资源大小。

  GZIP 需要服务端配合，通常是配置web server，开启 compression 设置，这样最终资源的 response header 里会包含 Content-encoding: gzip 的信息；浏览器自动识别这个header，解析response

  GZIP测试：http://www.gidnetwork.com/tools/gzip-test.php

  __注意__: 一些文件格式本身就已经是压缩后的资源，比如：JPEG,PNG,GIF,WOFF，所以不需要对这些文件采用上面的压缩方式进行处理

### 图片优化
  1. 去除不必要的图片：反问下是否必须使用图片，是否可以用其他方式来代替比如 css3 effects、 web fonts；如果必须用图片，是否可以延后加载；如果也不能延后，最后再考虑如何减少大小
  1. 选择合适的图片类型 (要动画就得用gif、要高分辨保留精细的细节就用png；要优化图片、屏幕截图 就用 jpeg)
  1. 移除 图片元数据，大多数图片会包含一些类似 拍摄时间、设备、文件格式、宽度、分辨率、作者等等，这些信息对应大多数站点并不需要，所以可以通过工具将这些信息去除掉，比如 VerExif
  1. 根据实际使用需要，提供相应的图片大小，而不是提供一张大的图片，然后交由浏览器自动适配图片显示。
  1. 降低图片质量。PNG 和 JPG 图片可以通过压缩工具进行再压缩。免费在线图片压缩工具 TinyPng：https://tinypng.com/

### 谨慎引入第三方包

### 优化javascript

#### tree shaking

#### code splitting

## 减少请求数

### 合并文本资源

  这个方法一般用在 JS/CSS 文件上，目前比较热门的打包工具，比如 webpack 就是将 js/css 内容打包成一个大的文件。

### 合并图片

  最常见的就是 Sprite 的使用，将一些小图片集合到一张大图片上面，然后通过 css 显示对应图片区域。采用这种方式，能将对几个小图片的请求合并成一个请求，有效减少请求数。不过带来的缺点是增加获取对应图片区域的使用复杂度。

### inline css/js

  对于一些特定页面的样式和逻辑，如果内容不多，可以将这些内容直接写到 html 文件里，这样就无需额外去加载特定的 css/js 文件。带来的一个问题是增加了 html 文件的大小，所以需要取舍。

### 图片采用 data-uri 格式

  类似于 inline css/js，图片可以以 data-uri 的格式被使用，通常在css background 和 html image 标签里会见到。采用这种方法，图片是被转成 base64 格式直接嵌入到 css/html 文件里，不需要额外的http 请求。

  当然这种方式也有缺点，通常转成base64格式后，图片大小会更大，同时也增加了 css/html 文件大小，因此也不能滥用这种优化方法。

### http caching

  相比于前面提到的优化手段，缓存对于性能的提升是最明显的。通过缓存，可以省去最耗时的 http 请求，资源直接从 内存、硬盘中获取。

  使用 Cache-Control 请求头，配置资源的缓存策略。对于一些基本不怎么会修改的资源，可以长时间的缓存，比如百度首页的logo图片。还有一些公共的js库，一般应用开发后也基本不会变，也可以设置长的缓存时间。

  缓存带来的好处是很明显，当然也带来另外一个问题：如何更新内容已经发生变更的缓存？目前常用的方法是结合 ETag response 头对缓存进行校验，也可以通过编程实现(通常是在客户端和服务端共同持有一个version信息)

## 优化资源加载顺序

### critical rendering path

### 将 样式/css文件 放在html的顶部

  浏览器在渲染页面前，需要先构建 DOM 和 CSSOM，然后合成 Object Model，因此 css 内容要尽早加载下来，这样才不会影响页面的渲染速度。

### 将 js 脚本/文件 放在html的底部

  浏览器在解析html文档内容时，碰到js脚本/文件时时，会暂停解析，让JS引擎进行脚本执行，因此应该把 js 脚本/文件 放到html底部，否则会阻塞html的渲染，影响页面的展现速度。

## 其他方面

### web font 优化

### js 启动的优化

#### 网络请求

  可以通过以下方式降低网络传输成本：

  1. 仅发送用户所属的代码： 使用 code split 将 js 拆分成 关键部分 和 非关键部分(webpack可以做到)；lazy loading非关键代码
  1. minify：使用 UglifyJS 来压缩 ES5 代码； 使用 babel-minify 或 uglify-es 来压缩 ES2015+
  1. gzip：使用 gzip 压缩基于文本的资源； 考虑使用 Brotli ~q11， 压缩率要优于 gzip
  1. 移除未使用的代码： 识别可以使用 DevTools 代码覆盖来移除或延迟加载代码的机会； 使用 babel-preset-env 和 browserlist，避免转译现代浏览器中已有的功能；  tree-shaking、Closure Compiler 的高级优化和库裁剪插件 或者 webpack 的 ContextReplacementPlugin（适用于 Moment.js 等库） 来移除代码
  1. 缓存代码以最大限度减少网络往返次数
    + 使用http caching，确定最佳 max-age，并提供 E-tag以避免传输未更改的字节
    + server worker 缓存可以确保应用更有弹性
    + 使用长期缓存以避免重新获取未更改的资源

#### 解析/编译

#### 执行时间

#### 其他成本

1. 内存： 页面可能会因为GC而出现卡顿或者频繁暂停的现象。当浏览器回收内存时，会暂停执行js。所以要避免内存泄漏和频繁的GC操作
1. 长时间运行的js会阻塞主线程，导致页面无法响应。可以将代码拆分成较小的块(使用 requestAnimationFrame() 或 requestIdleCallback() ) 可以最大限度减少无响应问题。
