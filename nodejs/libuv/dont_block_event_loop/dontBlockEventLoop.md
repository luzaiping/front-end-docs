不要阻塞 event loop (或是 ThreadPool)
=======================================

这篇是对 event_loop 的扩展，内容完全取自[官网文档](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/)。由于内容确实是很好，这边就直接抄写下来，当做是加强理解。

这篇文档是以 Nodejs 服务器开发的角度编写。但这些概念也同样适用于复杂的 Nodejs 应用程序。

## 概述

Nodejs 通过 Event Loop 机制 (初始化和callback) 的方式运行 JS 代码，并且提供了一个线程池处理诸如文件 I/O 等高成本的任务。Nodejs 的伸缩性非常好，某些场景下它甚至比类似 Apache 等更重量级的解决方案要表现得更优异。Nodejs 可伸缩性的秘诀在于它仅使用了极少数的线程就可以处理大量的客户端连接。如果 Nodejs 只需占用很少的线程，那么它就可以将更多的系统 CPU 时间和内存花费在客户端任务而不是线程的空间和时间消耗上(内存、上下文切换)。但是由于使用了少量线程，因此必须非常小心地组织应用以便合理地使用它们。

这里有一个很好的经验法则，能使你的 Nodejs 服务器变快：在任何时候，当分配到每个客户端的任务是 `少量` 的情况下，Nodejs 是非常快的。

这条法则适用于 Event Loop 的 callback，也适用于在 ThreadPool 上的任务。

## 为什么不要阻塞 Event Loop (或者 ThreadPool)

在 Nodejs 中，有两种类型的线程：

+ 一个 Event Loop 线程 (也成为 主循环、主线程、事件线程 等)
+ 另一个是 ThreadPool 里的 k 个工程线程

如果一个线程执行 callback (Event Loop 线程) 或者 任务 (工作线程) 需要耗费很长的时间，我们称之为 `"阻塞"`。当一个线程在处理某一个客户端请求时被阻塞，它就无法处理其他客户端的请求。这里给出两个不能阻塞 Event Loop 线程 和 工作线程的理由：

1. 性能：如果在任意类型的线程上频繁处理繁重的任务，那么服务器的 `吞吐量(请求/秒)` 将面临严峻考验
1. 安全：如果特定的请求，某种类型的线程会被阻塞，那么攻击者就可以通过构造类似这样的请求，故意让你的线程阻塞，然后其他客户端请求就得不到请求。这就是拒绝服务攻击 (DOS)

## Nodejs 快速回顾

Nodejs 使用事件驱动机制：它有一个 Event Loop 线程负责任务编排，和一个专门处理繁重任务的工作线程池。

### 哪种代码运行在 Event Loop 线程 ？

当 Nodejs 程序运行时，程序首先完成初始化部分，即处理 require 加载的模块 和 注册事件 callback。然后 Nodejs 应用程序进入 Event Loop 阶段，通过执行对应 callback 来对客户端请求进行响应。callback 函数将同步执行，并且可能在执行完成后注册新的异步请求，这些异步请求的 callback 也会被 Event Loop 线程 处理。

Event Loop 线程同样包含很多非阻塞异步请求的 callback，比如 网络 I/O。

总体来说，Event Loop 线程执行事件的 callback 函数，并且负责处理类似网络 I/O 的非阻塞异步请求。

### 哪种代码运行在工作线程池？

Nodejs 的工作线程池是通过 libuv 来实现，它对外提供了一个通用的任务处理API。

Nodejs 使用工作线程池来处理 `高成本` 的任务。这包括操作系统并没有提供非阻塞版本的 I/O 操作，以及一些 CPU 密集型的任务。

Nodejs 模块中有如下 API 使用了工作线程池：

1. I/O 密集型任务：
> 1. DNS: dns.lookup(), dns.lookupservice()
> 1. File System：所有 fs API，除了 fs.FSWatcher() 和 那些显示同步调用的 API 之外，都使用 libuv 的线程池

1. CPU 密集型任务：
> 1. Crypto: crypto.pbkdf2()、crypto.scrypt()、crypto.randomBytes()、crypto.randomFill()、crypto.generateKeyPair()
> 1. Zlib: 所有 Zlib 相关函数，除了那些显示同步调用的 API 之外，都使用了 libuv 的线程池。

在许多 Nodejs 应用程序中，这些 API 是工作线程池任务的唯一来源。此外应用程序和模块可以使用 `C++ 插件` 向工作线程池提交其他任务。

为了完整性考虑，必须说明的是，当在 Event Loop 线程 的一个 callback 函数中调用了这些 API， Event Loop 线程将不得不为此耗费少量的额外开销，因为它必须要进入对应 API 与 C++ 桥接通信的 Nodejs C++ binding 中，从而向工作线程池提交一个任务。和整个任务的成本相比，这些开销是微不足道。这就是为什么 Event Loop 线程总是将这些任务转交给工作线程池的原因。当向工作线程池提交了某个任务，Nodejs 会在 C++ binding 中为对应的 C++ 函数提供一个指针。

### Nodejs 怎么决定下一步该运行哪些代码？

抽象来说，Event Loop 线程 和 工作池线程分别为等待中的事件 callback 和 等待中的任务维护一个队列。

事实上，Event Loop 线程本身并不维护队列，它持有一堆要求操作系统使用诸如 epoll 等机制去监听的文件描述符。这些文件描述符可能代表一个网络 socket，一个监听的文件等。当操作系统确定某个文件的描述符发生变化，Event Loop 线程将把它转换为合适的事件。然后触发与该事件对应的 callback。

相比而已，工作线程池则使用一个真实的队列，里面包含了要被处理的任务。一个工作线程从队列中取出一个任务，开始处理它。当完成之后，这个工作线程向 Event Loop 线程发出一个 `至少一个任务完成了` 的消息。

## 对于设计而言，这意味着什么？

在类似 Apache 这种`一个客户端连接一个线程` 的系统中，每个处理中的客户端被分配了一个独立的线程。如果处理某个客户端请求的线程被阻塞了，操作系统会中断它，并给予下一个客户端请求执行的机会。操作系统必须保证一个只需要少量开销的客户端请求不会被其他需要大量开销的客户端请求影响。

因为 Nodejs 用少量的线程处理许多客户端连接，如果在处理某个客户端请求的时候阻塞了，在该客户端请求的回调或任务完成之前，其他等待中的任务可能都不会得到执行机会。因此，保证每个请求得到公平的执行机会变成了应用程序的责任。这意味着，对于任意一个客户端请求，不应该在一个 callback 或 任务中做太多的事情。

这既是 Nodejs 服务能够保存良好伸缩性的原因，同时意味着应用程序必须自己确保公平调度。

## 不要阻塞 Event Loop 线程

Event Loop 线程关注着每个新的客户端连接，协调产生一个响应。所有这些进入的请求和输出的响应都要通过 Event Loop 线程。这意味着如果 Event Loop 线程 在某个地方花费了太多的时间，所有当前和未来的新客户端请求都得不到处理机会了。

因此，应该保证永不要阻塞 Event Loop 线程。换句话说，每个 JS callback 函数应该快速完成。这个对于 await，promise.then 同样适用。

一个能确保做到这一点的方法是分析关于你回调代码的 "计算复杂度"。 如果你的回调函数在任意的参数输入下执行步骤数量都相同，那么你总能保证每个等待中的请求得到一个公平的执行机会。 如果回调根据其参数不同所需要的执行步骤数量也不同， 则应深入考虑参数复杂度增长的情况下请求的可能执行时间增长情况。

### 应当注意些什么呢？

Nodejs 使用 V8 引擎处理 JS，对于大部分操作确实很快。但有个例外是 `正则表达式` 和 `JSON 的处理`。

### 阻塞 Event Loop：REDOS

一个灾难性地阻塞 Event Loop 的常见错误就是使用有漏洞的正则表达式。

#### 避免易受攻击的正则表达式

一个正则表达式是一定的规则去尝试匹配一个输入的字符串。 我们通常认为正则表达式的匹配需要扫描一次输入字符串—— O(n) 时间，其中 n 是输入字符串的长度。 在大部分情况下，一次扫描的确足够。 不幸的是，在某些情况下，正则表达式匹配扫描随着输入字符串呈指数增长——时间是 O(2^n)。 指数级的扫描时间消耗意味着如果引擎需要 x 时间来确定匹配；我们的输入仅仅只增加一个字符，它将需要 2 * x 的时间。 由于扫描的消耗与所需时间呈线性关系，因此，这种正则匹配将阻塞事件循环。

易受攻击的正则表达式 是指执行时间随输入指数级增长的情况， 它使您的应用程序在“恶意输入”的情况下面临 REDOS （正则表达式拒绝服务攻击）的风险。 一个正则表达式是否易受攻击的（例如，正则表达式引擎需要指数级的时间复杂度来执行），这实际上是一个很难回答的问题。并且根据您是用 Perl、Python、Ruby、Java、JavaScript 等不同的语言情况也有所不同，但这里有在一些在所有语言里都适用的一些经验法则：

1. 避免嵌套量词，如 (a+)*。Node.js 的正则表达式引擎可能可以快速处理某些例子，但某些则可能是易受攻击的。
1. 避免带有“或”的重叠情况，如 (a|a)*。同样，Node.js 只能保证某些场景下可以快速匹配。
1. 避免使用回溯，如 (a.*) \1。没有正则表达式引擎可以保证在线性时间内执行这种匹配。
1. 如果您只需要做简单的字符串匹配，请使用 indexOf 或其他等价 API。这些是更好的选择，它们永远不会超过 O(n) 的时间。

如果您不确定正则表达式是否易受攻击，请记住：即使对于一个易受攻击的正则表达式和长输入字符串，Node.js 通常也仍然可以确保结果正确匹配。 而指数爆炸的场景是出现在用户输入并不匹配正则特征，但是 Node.js 必须要尝试去执行非常多次的扫描才能最终得出结论。

下面是一个给服务器带来 REDOS 风险的示例示例：
```js
app.get('/redos-me', (req, res) => {
  let filePath = req.query.filePath;

  // REDOS
  if (filePath.match(/(\/.+)+$/)) {
    console.log('valid path');
  }
  else {
    console.log('invalid path');
  }

  res.sendStatus(200);
});
```

这个有漏洞的正则例子是一个(糟糕的！)检查 Linux 上合法路径的例子。 它匹配的字符串是以 "/" 分隔的名称序列，如 "/a/b/c"。 这是非常危险的，因为它违反了规则 1：它有一个双重嵌套的量词。

假设客户端查询的是路径 ///.../\n （100个“/”后跟一个正则表达式的“.”不匹配的换行符），则事件循环线程将持续执行且无法停止，从而阻止事件循环。 这类客户端发起的 REDOS 攻击会导致所有其它客户端在此正则表达式匹配完成之前得不到任何执行机会。

因此，您应该警惕使用复杂的正则表达式来验证用户输入的场景。

### 阻塞事件轮询：Node.js 的核心模块

一些 Nodejs 的核心模块有同步的高开销的 API 方法，包含：
+ crypto 加密
+ zlib 压缩
+ fs 文件系统
+ child_process 子进程

这些 API 是高开销的，因为它们包括了非常巨大的计算 (如加密、压缩)，需要 I/O (如 文件 I/O)，或者两者都有潜在包含 (如子进程处理)。这些 API 是为脚本提供方便，并非让你在服务器上下文中使用。如果你在 Event Loop 中使用它们，则需要花费比一般的 JS 更长的执行时间，从而可能导致 Event Loop 阻塞。

对于一个服务器而言，不应当使用以下同步的 API 函数：
+ 加密
> + crypto.randomBytes（同步版本）
> + crypto.randomFillSync
> + crypto.pbkdf2Sync
> + 同时要非常小心对加密和解密给予大数据输入的情况

+ 压缩
> + zlib.inflateSync
> + zlib.deflateSync

+ 文件系统
> + 不能使用同步文件系统的 API 函数。举个例子，如果你的应用程序运行于一个分布式文件系统，像 NFS，则访问时间会发生很大变化。

+ 子进程
> + child_process.spawnSync
> + child_process.execSync
> + child_process.execFileSync

### 阻塞事件循环：JSON DOS

JSON.parse 和 JSON.stringify 是其他潜在高开销的操作。这些操作的时间复杂度是 O(n), 对于大型的 n 输入，消耗的时间可能惊人的长。

有些 npm 的模块提供了异步的 JSON API 函数，参考：
+ JSONStream，有流式操作的 API。
+ Big-Friendly JSON，有流式 API 和使用下文所概述的任务拆分思想的异步 JSON 标准 API。

### 不要让复杂的计算阻塞事件循环

假设想在 JS 中处理一个复杂的计算，而不想阻塞 Event Loop。有两种选择：

+ 拆分任务
+ 任务分流

todo 这块内容相比要复杂很多，涉及数据结构和算法，暂时先不写，等后面理解更深了再补充

## 不要阻塞你的工作线程池

todo 同上